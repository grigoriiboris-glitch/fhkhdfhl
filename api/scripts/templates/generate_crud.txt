package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
	"log"
	"fmt"
	"unicode"
)

const crudTemplate = `package repository

import (
	"context"
	"time"
	"log"

	"{{.PackagePath}}/models"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

type {{.StructName}}Repository struct {
	db *pgxpool.Pool
}

func New{{.StructName}}Repository(db *pgxpool.Pool) *{{.StructName}}Repository {
	return &{{.StructName}}Repository{db: db}
}

// Create создает новую запись
func (r *{{.StructName}}Repository) Create(ctx context.Context, {{.LowerName}} *models.{{.StructName}}) error {
	query := `
	INSERT INTO {{.TableName}} ({{.InsertColumns}})
	VALUES ({{.InsertParams}})
	RETURNING id, {{.ReturnColumns}}`

	err := r.db.QueryRow(ctx, query, {{.InsertValues}}).Scan(
		&{{.LowerName}}.ID,{{range .ScanFields}}
		&{{$.LowerName}}.{{.}},{{end}}
	)

	return err
}

// GetByID возвращает запись по ID
func (r *{{.StructName}}Repository) GetByID(ctx context.Context, id int) (*models.{{.StructName}}, error) {
	query := `
	SELECT id, {{.ColumnList}}
	FROM {{.TableName}}
	WHERE id = $1`

	return r.queryRow(ctx, query, id)
}

// Update обновляет запись
func (r *{{.StructName}}Repository) Update(ctx context.Context, {{.LowerName}} *models.{{.StructName}}) error {
	query := `
	UPDATE {{.TableName}}
	SET {{.UpdateSet}}
	WHERE id = ${{.UpdateWhereParam}}
	RETURNING {{.ReturnColumns}}`

	err := r.db.QueryRow(ctx, query, {{.UpdateValues}}, {{.LowerName}}.ID).Scan(
		{{range .ScanFields}}
		&{{$.LowerName}}.{{.}},{{end}}
	)

	return err
}

// Delete удаляет запись по ID
func (r *{{.StructName}}Repository) Delete(ctx context.Context, id int) error {
	query := `DELETE FROM {{.TableName}} WHERE id = $1`
	_, err := r.db.Exec(ctx, query, id)
	return err
}

{{range .FieldMethods}}
// GetBy{{.FieldName}} возвращает запись по {{.FieldName}}
func (r *{{$.StructName}}Repository) GetBy{{.FieldName}}(ctx context.Context, {{.ParamName}} {{.FieldType}}) (*models.{{$.StructName}}, error) {
	query := `
	SELECT id, {{$.ColumnList}}
	FROM {{$.TableName}}
	WHERE {{.ColumnName}} = $1`

	return r.queryRow(ctx, query, {{.ParamName}})
}

// GetManyBy{{.FieldName}} возвращает записи по {{.FieldName}} с пагинацией
func (r *{{$.StructName}}Repository) GetManyBy{{.FieldName}}(ctx context.Context, {{.ParamName}} {{.FieldType}}, limit, offset int) ([]*models.{{$.StructName}}, error) {
	query := `
	SELECT id, {{$.ColumnList}}
	FROM {{$.TableName}}
	WHERE {{.ColumnName}} = $1
	ORDER BY id
	LIMIT $2 OFFSET $3`

	rows, err := r.db.Query(ctx, query, {{.ParamName}}, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	return r.scanRows(rows)
}
{{end}}
// queryRow вспомогательный метод для выполнения одиночного запроса
func (r *{{.StructName}}Repository) queryRow(ctx context.Context, query string, args ...interface{}) (*models.{{.StructName}}, error) {
	{{.LowerName}} := &models.{{.StructName}}{}
	err := r.db.QueryRow(ctx, query, args...).Scan(
		&{{.LowerName}}.ID,{{range .ScanFields}}
		&{{$.LowerName}}.{{.}},{{end}}
	)

	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return {{.LowerName}}, nil
}

// scanRows вспомогательный метод для сканирования нескольких строк
func (r *{{.StructName}}Repository) scanRows(rows pgx.Rows) ([]*models.{{.StructName}}, error) {
	var results []*models.{{.StructName}}

	for rows.Next() {
		{{.LowerName}} := &models.{{.StructName}}{}
		err := rows.Scan(
			&{{.LowerName}}.ID,{{range .ScanFields}}
			&{{$.LowerName}}.{{.}},{{end}}
		)
		if err != nil {
			return nil, err
		}
		results = append(results, {{.LowerName}})
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return results, nil
}
`

type FieldData struct {
	FieldName  string
	FieldType  string
	ParamName  string
	ColumnName string
	IsID       bool
}

type TemplateData struct {
	PackagePath       string
	StructName        string
	LowerName         string
	TableName         string
	ColumnList        string
	InsertColumns     string
	InsertParams      string
	InsertValues      string
	ReturnColumns     string
	UpdateSet         string
	UpdateValues      string
	UpdateWhereParam  int
	ScanFields        []string
	FieldMethods      []FieldData
	ExcludedFields    []string
}

func main() {
	if len(os.Args) < 3 {
		log.Fatal("Usage: go run generate_crud.go <model_file.go> <package_path>")
	}

	modelFile := os.Args[1]
	packagePath := os.Args[2]

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, modelFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatal("Error parsing file:", err)
	}

	var structData *ast.StructType
	var structName string

	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				structData = structType
				structName = typeSpec.Name.Name
				return false
			}
		}
		return true
	})

	if structData == nil {
		log.Fatal("No struct found in file")
	}

	data := prepareTemplateData(structData, structName, packagePath)

	tmpl := template.Must(template.New("crud").Parse(crudTemplate))

	outputFile := strings.ToLower(structName) + "_repository.go"
	file, err := os.Create(outputFile)
	if err != nil {
		log.Fatal("Error creating file:", err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		log.Fatal("Error executing template:", err)
	}

	fmt.Printf("Generated %s successfully!\n", outputFile)
}

func prepareTemplateData(structData *ast.StructType, structName, packagePath string) TemplateData {
	lowerName := strings.ToLower(structName[:1]) + structName[1:]
	tableName := strings.ToLower(structName) + "s"

	var fields []FieldData
	var insertColumns []string
	var insertParams []string
	var insertValues []string
	var returnColumns []string
	var updateSet []string
	var updateValues []string
	var scanFields []string
	var columnList []string

	paramCounter := 1
	excludedFields := []string{"ID"} // Поля, которые исключаем из insert

	for _, field := range structData.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		fieldName := field.Names[0].Name
		fieldType := getTypeName(field.Type)
		columnName := toSnakeCase(fieldName)

		// Пропускаем поля с тегом json:"-"
		if hasJSONIgnoreTag(field) {
			excludedFields = append(excludedFields, fieldName)
			continue
		}

		isID := fieldName == "ID"
		paramName := strings.ToLower(fieldName[:1]) + fieldName[1:]

		fieldData := FieldData{
			FieldName:  fieldName,
			FieldType:  fieldType,
			ParamName:  paramName,
			ColumnName: columnName,
			IsID:       isID,
		}

		fields = append(fields, fieldData)
		columnList = append(columnList, columnName)
		scanFields = append(scanFields, fieldName)

		if !isID {
			insertColumns = append(insertColumns, columnName)
			insertParams = append(insertParams, fmt.Sprintf("$%d", paramCounter))
			insertValues = append(insertValues, fmt.Sprintf("%s.%s", lowerName, fieldName))
			returnColumns = append(returnColumns, columnName)
			updateSet = append(updateSet, fmt.Sprintf("%s = $%d", columnName, paramCounter))
			updateValues = append(updateValues, fmt.Sprintf("%s.%s", lowerName, fieldName))
			paramCounter++
		}
	}

	updateWhereParam := paramCounter

	return TemplateData{
		PackagePath:      packagePath,
		StructName:       structName,
		LowerName:        lowerName,
		TableName:        tableName,
		ColumnList:       strings.Join(columnList, ", "),
		InsertColumns:    strings.Join(insertColumns, ", "),
		InsertParams:     strings.Join(insertParams, ", "),
		InsertValues:     strings.Join(insertValues, ", "),
		ReturnColumns:    strings.Join(returnColumns, ", "),
		UpdateSet:        strings.Join(updateSet, ", "),
		UpdateValues:     strings.Join(updateValues, ", "),
		UpdateWhereParam: updateWhereParam,
		ScanFields:       scanFields,
		FieldMethods:     fields[1:], // Пропускаем ID поле
		ExcludedFields:   excludedFields,
	}
}

func getTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return t.Sel.Name
	case *ast.ArrayType:
		return "[]" + getTypeName(t.Elt)
	case *ast.StarExpr:
		return "*" + getTypeName(t.X)
	default:
		return "interface{}"
	}
}

func hasJSONIgnoreTag(field *ast.Field) bool {
	if field.Tag == nil {
		return false
	}

	tag := field.Tag.Value
	return strings.Contains(tag, `json:"-"`)
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result = append(result, '_')
		}
		result = append(result, unicode.ToLower(r))
	}
	return string(result)
}